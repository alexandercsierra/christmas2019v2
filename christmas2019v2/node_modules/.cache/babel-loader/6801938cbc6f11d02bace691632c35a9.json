{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"./utils\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defaultConfig = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1, 3],\n  wind: [-0.5, 2],\n  changeFrequency: 200\n};\n/** An individual snowflake that will update it's location every call to `draw` */\n\nvar Snowflake =\n/*#__PURE__*/\nfunction () {\n  function Snowflake(_canvas) {\n    var _this = this;\n\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Snowflake);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"params\", void 0);\n\n    _defineProperty(this, \"framesSinceLastUpdate\", void 0);\n\n    _defineProperty(this, \"draw\", function (canvas, inputCtx) {\n      var ctx = inputCtx || canvas.getContext('2d');\n\n      if (ctx) {\n        ctx.beginPath();\n        ctx.arc(_this.params.x, _this.params.y, _this.params.radius, 0, 2 * Math.PI);\n        ctx.fillStyle = _this.fullConfig.color;\n        ctx.closePath();\n        ctx.fill();\n      }\n    });\n\n    _defineProperty(this, \"translate\", function (canvas) {\n      var framesPassed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var _this$params = _this.params,\n          x = _this$params.x,\n          y = _this$params.y,\n          wind = _this$params.wind,\n          speed = _this$params.speed,\n          nextWind = _this$params.nextWind,\n          nextSpeed = _this$params.nextSpeed; // Update current location, wrapping around if going off the canvas\n\n      _this.params.x = (x + wind * framesPassed) % canvas.offsetWidth;\n      _this.params.y = (y + speed * framesPassed) % canvas.offsetHeight; // Update the wind and speed towards the desired values\n\n      _this.params.speed = (0, _utils.lerp)(speed, nextSpeed, 0.01);\n      _this.params.wind = (0, _utils.lerp)(wind, nextWind, 0.01);\n\n      if (_this.framesSinceLastUpdate++ > _this.fullConfig.changeFrequency) {\n        _this.updateTargetParams();\n\n        _this.framesSinceLastUpdate = 0;\n      }\n    });\n\n    _defineProperty(this, \"updateTargetParams\", function () {\n      _this.params.nextSpeed = _utils.random.apply(void 0, _toConsumableArray(_this.fullConfig.speed));\n      _this.params.nextWind = _utils.random.apply(void 0, _toConsumableArray(_this.fullConfig.wind));\n    });\n\n    _defineProperty(this, \"update\", function (canvas, framesPassed) {\n      _this.translate(canvas, framesPassed);\n    }); // Set custom config\n\n\n    this.config = config; // Setting initial parameters\n\n    var _this$fullConfig = this.fullConfig,\n        radius = _this$fullConfig.radius,\n        _wind = _this$fullConfig.wind,\n        _speed = _this$fullConfig.speed;\n    this.params = {\n      x: (0, _utils.random)(0, _canvas.offsetWidth),\n      y: (0, _utils.random)(-_canvas.offsetHeight, 0),\n      radius: _utils.random.apply(void 0, _toConsumableArray(radius)),\n      speed: _utils.random.apply(void 0, _toConsumableArray(_speed)),\n      wind: _utils.random.apply(void 0, _toConsumableArray(_wind)),\n      nextSpeed: _utils.random.apply(void 0, _toConsumableArray(_wind)),\n      nextWind: _utils.random.apply(void 0, _toConsumableArray(_speed))\n    };\n    this.framesSinceLastUpdate = 0;\n  }\n\n  _createClass(Snowflake, [{\n    key: \"fullConfig\",\n    get: function get() {\n      return _objectSpread({}, defaultConfig, this.config);\n    }\n  }]);\n\n  return Snowflake;\n}();\n\nvar _default = Snowflake;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/Snowflake.ts"],"names":["defaultConfig","color","radius","speed","wind","changeFrequency","Snowflake","config","x","canvas","y","random","nextSpeed","nextWind","ctx","inputCtx","Math","framesPassed"],"mappings":"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","sourcesContent":["import { lerp, random } from './utils'\n\nexport interface SnowflakeProps {\n  color: string\n  radius: [number, number]\n  speed: [number, number]\n  wind: [number, number]\n  changeFrequency: number\n}\n\nexport type SnowflakeConfig = Partial<SnowflakeProps>\n\nconst defaultConfig: SnowflakeProps = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1, 3],\n  wind: [-0.5, 2],\n  changeFrequency: 200,\n}\n\ninterface SnowflakeParams {\n  x: number\n  y: number\n  radius: number\n  speed: number\n  wind: number\n  nextSpeed: number\n  nextWind: number\n}\n\n/** An individual snowflake that will update it's location every call to `draw` */\nclass Snowflake {\n  public config: SnowflakeConfig\n  private params: SnowflakeParams\n  private framesSinceLastUpdate: number\n\n  public constructor(canvas: HTMLCanvasElement, config: SnowflakeConfig = {}) {\n    // Set custom config\n    this.config = config\n\n    // Setting initial parameters\n    const { radius, wind, speed } = this.fullConfig\n\n    this.params = {\n      x: random(0, canvas.offsetWidth),\n      y: random(-canvas.offsetHeight, 0),\n      radius: random(...radius),\n      speed: random(...speed),\n      wind: random(...wind),\n      nextSpeed: random(...wind),\n      nextWind: random(...speed),\n    }\n\n    this.framesSinceLastUpdate = 0\n  }\n\n  private get fullConfig() {\n    return {\n      ...defaultConfig,\n      ...this.config,\n    }\n  }\n\n  public draw = (canvas: HTMLCanvasElement, inputCtx?: CanvasRenderingContext2D) => {\n    const ctx = inputCtx || canvas.getContext('2d')\n    if (ctx) {\n      ctx.beginPath()\n      ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI)\n      ctx.fillStyle = this.fullConfig.color\n      ctx.closePath()\n      ctx.fill()\n    }\n  }\n\n  private translate = (canvas: HTMLCanvasElement, framesPassed: number = 1) => {\n    const { x, y, wind, speed, nextWind, nextSpeed } = this.params\n\n    // Update current location, wrapping around if going off the canvas\n    this.params.x = (x + wind * framesPassed) % canvas.offsetWidth\n    this.params.y = (y + speed * framesPassed) % canvas.offsetHeight\n\n    // Update the wind and speed towards the desired values\n    this.params.speed = lerp(speed, nextSpeed, 0.01)\n    this.params.wind = lerp(wind, nextWind, 0.01)\n\n    if (this.framesSinceLastUpdate++ > this.fullConfig.changeFrequency) {\n      this.updateTargetParams()\n      this.framesSinceLastUpdate = 0\n    }\n  }\n\n  private updateTargetParams = () => {\n    this.params.nextSpeed = random(...this.fullConfig.speed)\n    this.params.nextWind = random(...this.fullConfig.wind)\n  }\n\n  public update = (canvas: HTMLCanvasElement, framesPassed?: number) => {\n    this.translate(canvas, framesPassed)\n  }\n}\n\nexport default Snowflake\n"]},"metadata":{},"sourceType":"script"}