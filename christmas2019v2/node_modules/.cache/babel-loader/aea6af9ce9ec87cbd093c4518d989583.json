{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useSnowfallStyle = exports.useComponentSize = exports.useSnowflakes = void 0;\n\nvar _react = require(\"react\");\n\nvar _Snowflake = _interopRequireDefault(require(\"./Snowflake\"));\n\nvar _config = require(\"./config\");\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/**\n * A utility function to create a collection of snowflakes\n * @param canvasRef A ref to the canvas element\n * @param amount The number of snowflakes\n * @param config The configuration for each snowflake\n */\n\n\nvar createSnowflakes = function createSnowflakes(canvasRef, amount, config) {\n  var snowflakes = [];\n\n  for (var i = 0; i < amount; i++) {\n    snowflakes.push(new _Snowflake[\"default\"](canvasRef.current, config));\n  }\n\n  return snowflakes;\n};\n/**\n * A utility hook to manage creating and updating a collection of snowflakes\n * @param canvasRef A ref to the canvas element\n * @param amount The number of snowflakes\n * @param config The configuration for each snowflake\n */\n\n\nvar useSnowflakes = function useSnowflakes(canvasRef, amount, config) {\n  var _useState = (0, _react.useState)([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      snowflakes = _useState2[0],\n      setSnowflakes = _useState2[1]; // Handle change of amount\n\n\n  (0, _react.useEffect)(function () {\n    setSnowflakes(function (snowflakes) {\n      var sizeDifference = amount - snowflakes.length;\n\n      if (sizeDifference > 0) {\n        return [].concat(_toConsumableArray(snowflakes), _toConsumableArray(createSnowflakes(canvasRef, sizeDifference, config)));\n      }\n\n      if (sizeDifference < 0) {\n        return snowflakes.slice(0, amount);\n      }\n\n      return snowflakes;\n    });\n  }, [amount, canvasRef, config]); // Handle change of config\n\n  (0, _react.useEffect)(function () {\n    setSnowflakes(function (snowflakes) {\n      return snowflakes.map(function (snowflake) {\n        snowflake.config = config;\n        return snowflake;\n      });\n    });\n  }, [config]);\n  return snowflakes;\n};\n/**\n * Returns the height and width of a HTML element, uses the `ResizeObserver` api if available to detect changes to the\n * size. Falls back to listening for resize events on the window.\n * @param ref A ref to the HTML element to be measured\n */\n\n\nexports.useSnowflakes = useSnowflakes;\n\nvar useComponentSize = function useComponentSize(ref) {\n  var _useState3 = (0, _react.useState)((0, _utils.getSize)(ref.current)),\n      _useState4 = _slicedToArray(_useState3, 2),\n      size = _useState4[0],\n      setSize = _useState4[1];\n\n  var resizeHandler = (0, _react.useCallback)(function () {\n    if (ref.current) {\n      setSize((0, _utils.getSize)(ref.current));\n    }\n  }, [ref]);\n  (0, _react.useLayoutEffect)(function () {\n    var _window = window,\n        ResizeObserver = _window.ResizeObserver;\n    if (!ref.current) return;\n    resizeHandler();\n\n    if (typeof ResizeObserver === 'function') {\n      var resizeObserver = new ResizeObserver(resizeHandler);\n      resizeObserver.observe(ref.current);\n      return function () {\n        return resizeObserver.disconnect();\n      };\n    } else {\n      window.addEventListener('resize', resizeHandler);\n      return function () {\n        return window.removeEventListener('resize', resizeHandler);\n      };\n    }\n  }, [ref, resizeHandler]);\n  return size;\n};\n/**\n * Utility hook that merges any provided styles with the default styles\n * @param overrides The style prop passed into the component\n */\n\n\nexports.useComponentSize = useComponentSize;\n\nvar useSnowfallStyle = function useSnowfallStyle(overrides) {\n  var styles = (0, _react.useMemo)(function () {\n    return _objectSpread({}, _config.snowfallBaseStyle, overrides || {});\n  }, [overrides]);\n  return styles;\n};\n\nexports.useSnowfallStyle = useSnowfallStyle;","map":{"version":3,"sources":["../src/hooks.ts"],"names":["createSnowflakes","snowflakes","i","Snowflake","canvasRef","useSnowflakes","setSnowflakes","sizeDifference","amount","snowflake","useComponentSize","size","setSize","ref","resizeHandler","ResizeObserver","resizeObserver","window","useSnowfallStyle","styles","snowfallBaseStyle","overrides"],"mappings":"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","sourcesContent":["import { useCallback, useLayoutEffect, useEffect, useState, MutableRefObject, CSSProperties, useMemo } from 'react'\nimport Snowflake, { SnowflakeConfig } from './Snowflake'\nimport { snowfallBaseStyle } from './config'\nimport { getSize } from './utils'\n\n/**\n * A utility function to create a collection of snowflakes\n * @param canvasRef A ref to the canvas element\n * @param amount The number of snowflakes\n * @param config The configuration for each snowflake\n */\nconst createSnowflakes = (\n  canvasRef: React.MutableRefObject<HTMLCanvasElement | undefined>,\n  amount: number,\n  config: SnowflakeConfig,\n) => {\n  const snowflakes: Snowflake[] = []\n\n  for (let i = 0; i < amount; i++) {\n    snowflakes.push(new Snowflake(canvasRef.current as HTMLCanvasElement, config))\n  }\n\n  return snowflakes\n}\n\n/**\n * A utility hook to manage creating and updating a collection of snowflakes\n * @param canvasRef A ref to the canvas element\n * @param amount The number of snowflakes\n * @param config The configuration for each snowflake\n */\nexport const useSnowflakes = (\n  canvasRef: React.MutableRefObject<HTMLCanvasElement | undefined>,\n  amount: number,\n  config: SnowflakeConfig,\n) => {\n  const [snowflakes, setSnowflakes] = useState<Snowflake[]>([])\n\n  // Handle change of amount\n  useEffect(() => {\n    setSnowflakes(snowflakes => {\n      const sizeDifference = amount - snowflakes.length\n\n      if (sizeDifference > 0) {\n        return [...snowflakes, ...createSnowflakes(canvasRef, sizeDifference, config)]\n      }\n\n      if (sizeDifference < 0) {\n        return snowflakes.slice(0, amount)\n      }\n\n      return snowflakes\n    })\n  }, [amount, canvasRef, config])\n\n  // Handle change of config\n  useEffect(() => {\n    setSnowflakes(snowflakes =>\n      snowflakes.map(snowflake => {\n        snowflake.config = config\n        return snowflake\n      }),\n    )\n  }, [config])\n\n  return snowflakes\n}\n\n/**\n * Returns the height and width of a HTML element, uses the `ResizeObserver` api if available to detect changes to the\n * size. Falls back to listening for resize events on the window.\n * @param ref A ref to the HTML element to be measured\n */\nexport const useComponentSize = (ref: MutableRefObject<HTMLElement | undefined>) => {\n  const [size, setSize] = useState(getSize(ref.current))\n\n  const resizeHandler = useCallback(() => {\n    if (ref.current) {\n      setSize(getSize(ref.current))\n    }\n  }, [ref])\n\n  useLayoutEffect(() => {\n    const { ResizeObserver } = window\n\n    if (!ref.current) return\n    resizeHandler()\n\n    if (typeof ResizeObserver === 'function') {\n      const resizeObserver = new ResizeObserver(resizeHandler)\n      resizeObserver.observe(ref.current)\n\n      return () => resizeObserver.disconnect()\n    } else {\n      window.addEventListener('resize', resizeHandler)\n\n      return () => window.removeEventListener('resize', resizeHandler)\n    }\n  }, [ref, resizeHandler])\n\n  return size\n}\n\n/**\n * Utility hook that merges any provided styles with the default styles\n * @param overrides The style prop passed into the component\n */\nexport const useSnowfallStyle = (overrides?: CSSProperties) => {\n  const styles = useMemo(\n    () => ({\n      ...snowfallBaseStyle,\n      ...(overrides || {}),\n    }),\n    [overrides],\n  )\n\n  return styles\n}\n"]},"metadata":{},"sourceType":"script"}